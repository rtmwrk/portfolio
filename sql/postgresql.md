# ![](../assets/img/postgresql.png) Диалект PostgreSQL

### 1. Определение данных (DDL)


**1.1. Создание БД:**
```
CREATE DATABASE school;
```

**1.2. Изменение БД:**
```
ALTER DATABASE school RENAME TO sch;
```

**1.3. Удаление БД:**
```
DROP DATABASE sch;
```

**1.4. Создание таблицы:**
```
CREATE TABLE discipline (id_disc numeric (3), name_disc varchar (30), code_disc varchar (4));
 
CREATE TABLE public.exam (id_exam numeric(4) NOT NULL GENERATED BY DEFAULT AS IDENTITY,
                          name_exam varchar(30) NOT NULL, id_disc numeric(3) NOT NULL,
                          prim_exam text NULL, CONSTRAINT pr_key_exam PRIMARY KEY (id_exam),
                          CONSTRAINT un_key_exam UNIQUE (id_disc),
                          CONSTRAINT exam_fk FOREIGN KEY (id_disc) REFERENCES public.discipline(id_disc)
                          ON DELETE CASCADE ON UPDATE CASCADE);
```

**1.5. Добавить столбец:**
```
ALTER TABLE discipline ADD COLUMN prim_disc TEXT;
```

**1.6. Переименовать столбец:**
```
ALTER TABLE discipline RENAME COLUMN id_disc TO id;
```

**1.7. Изменить тип данных столбца:**
```
ALTER TABLE discipline ALTER COLUMN name_disc SET DATA TYPE TEXT;
```

**1.8. Удалить столбец:**
```
ALTER TABLE discipline DROP COLUMN id_disc;
```

**1.9. Установить на поле ограничение «NOT NULL»:**
```
ALTER TABLE discipline ALTER COLUMN code_disc SET NOT NULL;
```

**1.10. Установить на поле ограничение «UNIQUE»:**
```
ALTER TABLE discipline ADD UNIQUE (name_disc);
```

**1.11. Добавить первичный ключ:**
```
ALTER TABLE discipline ADD PRIMARY KEY (id_disc);
```

**1.12. Удалить первичный ключ:**
```
ALTER TABLE discipline DROP CONDTRAINT discipline_pkey;
```

**1.13. Переименование таблицы:**
```
ALTER TABLE IF EXIST discipline RENAME TO disc;
```

**1.7. Удаление таблицы:**
```
DROP TABLE disc;
```

...

___


### 2. Манипуляция с данными (DML)

**2.1. Вставка новых данных в строку таблицы:**
```
INSERT INTO discipline VALUES (1,'Математика','SC01');
 
INSERT INTO discipline VALUES (3,'Русский язык','SC03'),
                              (4,'Русская литература','SC04');
```

**2.2. Изменение данных в строке таблицы:**
```
UPDATE discipline SET id_disc = 7 WHERE id_disc = 6;
 
UPDATE discipline SET id_disc = 7 WHERE id_name = ‘Биология’;
```

**2.3. Удаление данных в строке таблицы:**
```
DELETE FROM discipline WHERE name_disc='Математика';
```

**2.4. Вывод всех строк таблицы:**
```
SELECT * FROM discipline;
```

**2.5. Вывод поля «id_disc» всех строк таблицы:**
```
SELECT id_disc FROM discipline;
```

**2.6. Вывод полей таблицы с заменой заголовков столбцов:**
```
SELECT name_disc AS "Наименование учебной дисциплины",
       code_disc AS "Код дисциплины" FROM discipline;
```

**2.7. Вывод всех строк таблицы + сортировка по полю:**

//-- По возрастанию значения
```
SELECT * FROM discipline ORDER BY id_disc ASC;
```

//-- По убыванию значения
```
SELECT * FROM discipline ORDER BY id_disc DESC;
```

//-- По нескольким полям
```
SELECT * FROM exam ORDER BY char_length(name_exam) ASC, id_disc ASC;
```

**2.8. Вывод 2 строк таблицы, начиная со 2-й:**
```
SELECT * FROM exam LIMIT 2 OFFSET 1;
```

**2.9. Вывод строк таблицы с условиями:**
```
SELECT * FROM discipline WHERE id_disc >= 10 AND id_disc <= 11;

SELECT * FROM discipline WHERE id_disc = 10 OR id_disc = 11;

SELECT * FROM discipline WHERE id_disc BETWEEN 8 AND 11 ORDER BY id_disc;

SELECT * FROM discipline WHERE id_disc IN (2,4,6,8) ORDER BY code_disc;
```

**2.10. Вывод строк таблицы с разделением на диапазоны:**
```
SELECT name_disc "Наименование дисциплины",
       CASE
       WHEN id_disc <= 5 THEN 'Базовые дисциплины'
       WHEN id_disc BETWEEN 6 AND 10 THEN 'Расширенный курс'
       ELSE 'Дополнительные дисциплины'
       END AS "Тип дисциплины"
       FROM discipline ORDER BY code_disc;
```

**2.11. Вывод строк таблицы с группировкой:**
```
SELECT id_disc FROM discipline GROUP BY id_disc OREDER BY id_disc;
```

**2.12. Вывод строк таблицы с добавлением инкрементного поля:**

//-- Таблица не корректируется, поле добавляется только в выборку
```
SELECT row_number () over() AS "№ п/п", 
       name_disc AS "Наименование учебной дисциплины", 
       code_disc AS "Код дисциплины" FROM discipline;

SELECT row_number () over() AS "№ п/п", 
       name_disc as "Наименование учебной дисциплины", 
       code_disc AS "Код дисциплины" from discipline;
```

**2.13. Вывод строк таблицы с «хорошими» регулярными выражениями:**

//-- Значение поля = «История»
```
SELECT * FROM discipline WHERE name_disc LIKE 'История' ORDER BY code_disc;
```

//-- Значения поля начинаются на букву «И»
```
SELECT * FROM discipline WHERE name_disc LIKE 'И%' ORDER BY code_disc;
```

//-- Значения поля содержит букву «Т»
SELECT * FROM discipline WHERE name_disc LIKE '%T%' ORDER BY code_disc;

**2.14. Вывод строк таблицы с со значениями «NULL»:**
```
SELECT * FROM discipline WHERE prim_disc IS NULL;

SELECT * FROM discipline WHERE prim_disc IS NOT NULL;
```

**2.15. Выборка с объединением таблиц (JOIN):**

//-- Кросс-джоин – объединение всех строк 1-й таблицы со всеми строками 2-й
```
SELECT discipline.code_disc, discipline.name_disc, exam.prim_exam, exam.data_exam
       FROM discipline, exam 
       CROSS JOIN exam 
       ORDER BY discipline.code_disc, exam.data_exam;
```

//-- Внешний-джоин – объединение строк, 1-я таблица полностью + строки 2-й, 
     где нет во 2-й прямого соответствия со строками 1-й – выставляется NULL
```
SELECT discipline.code_disc, discipline.name_disc, exam.prim_exam, exam.data_exam
       FROM discipline
       FULL OUTER JOIN exam on discipline.id_disc = exam.id_disc
       ORDER BY discipline.code_disc, exam.data_exam;
```

//-- Внешний-левый-джоин – объединение строк, 1-я таблица полностью + строки 2-й,
     где нет во 2-й прямого соответствия со строками 1-й – выставляется NULL.
     В данном случае результат такой же как и FULL OUTER JOIN
```
SELECT discipline.code_disc, discipline.name_disc, exam.prim_exam, exam.data_exam
       FROM discipline
       LEFT OUTER JOIN exam on discipline.id_disc = exam.id_disc
       ORDER BY discipline.code_disc, exam.data_exam;
```

//-- Внешний-правый-джоин – объединение строк, 2-я таблица полностью + строки 1-й,
     где нет во 1-й прямого соответствия со строками 2-й – выставляется NULL.
     В данном случае результат такой же как и INNER JOIN
```
SELECT discipline.code_disc, discipline.name_disc, exam.prim_exam, exam.data_exam
       FROM discipline
       RIGHT OUTER JOIN exam on discipline.id_disc = exam.id_disc
       ORDER BY discipline.code_disc, exam.data_exam;
```

//-- Внутренний-джоин – объединение строк, которые есть и в 1-й, и во 2-й таблице
```
SELECT discipline.code_disc, discipline.name_disc, exam.prim_exam, exam.data_exam
       FROM discipline
       INNER JOIN exam ON discipline.id_disc = exam.id_disc
       ORDER BY discipline.code_disc, exam.data_exam;   
```

...

___       
***PostgreSQL v. 15.3***